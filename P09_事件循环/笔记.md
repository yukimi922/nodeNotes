## 浏览器的事件循环
### 什么是事件循环？

是我们编写的代码和浏览器或者和node之前的桥梁

 

- 浏览器事件循环
  - 连接我们编写的js代码和浏览器api的桥梁，通过回调函数进行沟通
- node事件循环
  - 是我们编写的js代码与系统(file system、network等node的系统)调用之间的桥梁，通过回调函数沟通



### 进程和线程



- 进程

  - 计算机已经运行的程序
  - 启动一个应用程序，就会默认开启一个进程或者多个进程(依赖关系)

- 线程 

  - 操作系统能够运行运算调度的最小单位

  - 每一个进程中，都会启动一个线程来执行程序中的代码，为主线程

  - 进程是线程的容器

    


### 宏任务队列与微任务队列

- 宏任务队列
  - ajax、timeout、setinterval、DOM监听、页面渲染等

- 微任务队列
  - promise().then()回调、或者自己定义微任务。
  - await 调用后，后面的代码相当于是then后面的调用，属于微任务

  ```js
  async fun(){
      await fun2();
      console.log(111); // 不属于JavaScript队列中的内容，属于微任务
  }
  ```

 

**如果微任务队列和宏任务队列同事存在事件，则优先执行微任务队列，全部执行完再执行宏任务队列**


**在执行每一个宏任务之前，浏览器会先查找微任务是否有事件，如果有，先执行完微任务的事件，再执行宏任务**



## node的事件循环

 浏览器中的eventloop是由HTML5指定的规范去执行的，每个浏览器的规范并不完全相同。node中是由libuv去实现的.




### 阻塞式IO与非阻塞式IO

- 阻塞式IO
  - 在执行一个操作之后，系统必须等到操作完成，返回操作结果之后再继续向后执行。
- 非阻塞式IO
  - 在执行一个任务之后，系统不会产生阻塞，会立即返回执行结果，继续执行后面的任务，但是此时返回的结果并不是我们想要获取的完整结果， 我们需要在执行任务的同时反复去确认数据是否完整。这个过程称之为**轮训操作**

  
 
### 同步与异步

*同步 -----> 阻塞*

*异步 -----> 非阻塞*

- 阻塞或者非阻塞是对于被调用者来说(系统调用)

- 同步或者异步是对于调用者来说(我们自己的程序)

  
### 轮训操作

如果主线程反复的去做轮训操作，会大大降低性能。libuv提供了线程池，**线程池**会负责相关的所有操作，并且通过轮训或者其他方式等待结果。

*libuv采用的是非阻塞式异步IO*

### node事件循环阶段

node中有五个队列，分别为：

- main script
- nextticks
- other microtask(微任务)
- timers
- immediate

node的一次事件循环中，依次执行


V8将JavaScript语言翻译成libuv可以中libuv(event loop)可以执行的语言，libuv再通过底层控制操作系统(比如fs文件系统)执行对应命令。

JavaScript --> V8 --> libuv  整体组成node的基本